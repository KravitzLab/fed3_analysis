<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fed3.plot.barchart API documentation</title>
<meta name="description" content="Bar charts â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fed3.plot.barchart</code></h1>
</header>
<section id="section-intro">
<h1 id="bar-charts">Bar charts</h1>
<p>The barchart module (<code>fed3.plot.barchart.py</code>) creates bar plots from FED3 data. Some example bar plots are demonstrated below.
We will start by loading fed3 and some data:</p>
<pre><code class="language-python">import fed3
import fed3.plot as fplot

feds = fed3.load_examples('fr1', deduplicate_index='offset', offset='1s')
</code></pre>
<p>Some basic plotting parameters are also set for the purposes of documentation:</p>
<pre><code class="language-python">%matplotlib inline
import matplotlib.pyplot as plt

plt.rcParams['figure.figsize'] = [4, 5]
plt.rcParams['figure.dpi'] = 100
</code></pre>
<h2 id="basic-bar-charts">Basic bar charts</h2>
<p>The simplest bar plots show a value of interest (<code>y</code>) for one or more FEDFrames.
This defaults to being a measure of pellets earned:</p>
<pre><code class="language-python">fig = fplot.bar(feds)
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_6_0.png"></p>
<p>Commands from matplotlib can be used to clean up the figure:</p>
<pre><code class="language-python"># define some custom colors
colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']

# replot, removing the legend so it can be explicitly placed
# note that fplot.argh is used to distribute the colors to each bar
fig = fplot.bar(feds, legend=False, color=fplot.argh(colors), edgecolor='black')
plt.legend(bbox_to_anchor=[1, 1, 0, 0])

# nice command for formatting xticks
fig.autofmt_xdate()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_8_0.png"></p>
<p>The value plotted for individual bars is based on three parameters:
- <code>y</code>: The metric being plotted, such as 'pellets' or 'left_pokes' or 'retrieval_time'.
See <code><a title="fed3.metrics" href="../metrics/index.html">fed3.metrics</a></code> for all the options.
- <code>stat</code>: This determines how the timeseries metrics are collapsed into a single point value.
The default is 'max', other typical options would be 'mean' or 'median'.
- <code>normalize</code>: A time delta can be provided to normalize the values so they are on a per-unit-time scale.
This can be useful when FEDs are recorded for different lengths of time.</p>
<pre><code class="language-python"># pokes are normalize to be per hour
fig = fplot.bar(feds, y='pokes', normalize='1H', legend=False)
fig.autofmt_xdate()
plt.show()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_10_0.png"></p>
<h3 id="positioning-bars">Positioning bars</h3>
<p>There is a basic syntax for grouping the positions of bars together.
This is somewhat limited, but should be usable for many simple bar plots.
The primary argument is <code>positions</code>.
This argument accepts a list with one integer for each bar being plotted - bars receiving the same integer will be placed side-by-side:</p>
<pre><code class="language-python">positions = [0, 0, 0, 1, 1, 1, 1]

fig = fplot.bar(feds, y='ipi', stat='mean', positions=positions, legend=False)
plt.show()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_12_0.png"></p>
<p>There is also a <code>position_labels</code> function which can be used to label each group:</p>
<pre><code class="language-python">positions = [0, 0, 1, 1, 2, 2, 2]
position_labels = ['A', 'B', 'C']

fig = fplot.bar(feds,y='motor', stat='max',
                positions=positions,
                position_labels=position_labels,
                legend=False)
plt.show()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_14_0.png"></p>
<h2 id="grouping-data">Grouping data</h2>
<p>Dictionaries can be used to place FEDFrames into named groups.
In this case, their data are aggregated into a single bar:</p>
<pre><code class="language-python">grouped = {'Control': feds[:3], 'Treatment': feds[3:]}

fig = fplot.bar(grouped, y='pellets', stat='max')
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_16_0.png"></p>
<p>A few extra arguments control the grouping of data.
<code>agg</code> determines the function for aggregating the point values computed for each FEDFrame in the group, while <code>var</code> determines the metric to include in the error bars.</p>
<pre><code class="language-python">fig = fplot.bar(grouped, y='pellets', stat='max', agg='median')
plt.show()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_18_0.png"></p>
<p>Note the difference between <code>stat</code> and <code>agg</code>: <code>stat</code> determines how a time series metric derived from each FEDFrame is converted into a single value, while <code>agg</code> determines how those single values are converted into a single bar.
<code>agg</code> is only relevant when grouping data.</p>
<p>Instead of (or in addition to) the error bars, the <code>show_individual</code> argument can plot each FEDFrame's datum as a single point floating around the bar (with a little random jitter, as determined by <code>spread</code>):</p>
<pre><code class="language-python">fig = fplot.bar(grouped, y='pellets', stat='max', agg='median', var=None, show_individual=True)
plt.show()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_20_0.png"></p>
<p>The <code>positions</code> argument can also be used to control the placement of grouped data:</p>
<pre><code class="language-python"># this uses a trick:
# labels starting with an underscore are not included in the legend by matplotlib
groups2 = {'Saline': feds[0:2], 'Drug': feds[2:4], '_Saline': feds[4:6], '_Drug': feds[6:]}
positions = [0, 0, 1, 1]
colors = ['gray', 'dodgerblue'] * 2

fig = fplot.bar(groups2,
                y='ipi',
                stat='mean',
                positions=positions,
                position_labels=['WT', 'Knockout'],
                color=fplot.argh(colors))
plt.show()
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/main/img/plots_barchart/plots_barchart_22_0.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
.. include:: ../../docs/plots_barchart.md
&#34;&#34;&#34;

__all__ = [&#39;bar&#39;]

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from fed3.core.fedfuncs import screen_mixed_alignment

from fed3.metrics.core import get_metric
from fed3.metrics.tables import _bar_metric_df

from fed3.plot import OPTIONS
from fed3.plot.helpers import (_get_most_recent_color,
                               _get_return_value,
                               _parse_feds,
                               _process_plot_kwargs)

def _assign_bar_positions_widths(feds_dict, positions_arg=None, position_width=0.75):
    &#39;&#39;&#39;Determine placement of bars from a dicionary of FEDs to be plotted.&#39;&#39;&#39;

    if positions_arg is None:
        positions_arg = np.arange(len(feds_dict))

    if len(positions_arg) != len(feds_dict):
        raise ValueError(&#39;positions argument must equal the length of the input&#39;)

    positions = np.array(positions_arg, dtype=&#39;int&#39;)

    if any(np.diff(positions) &gt; 1):
        raise ValueError(&#34;positions must be only integers with none skipped.&#34;)

    centers, counts = np.unique(positions, return_counts=True)
    bw = position_width / max(counts)

    positions = []
    bar_widths = []
    for x, c in zip(centers, counts):
        start = x - (.5 * c * bw)
        end  = x + (.5 * c * bw)
        positions += list(np.arange(start + bw/2, end, bw))
        bar_widths += [bw] * c

    return centers, positions, bar_widths

def _jitter_ys(ys, xcenter, spread):
    &#39;&#39;&#39;Create jitter in x for raw data being plotted in a bar chart.&#39;&#39;&#39;

    xs = np.random.uniform(0, spread/2, size=len(ys))
    half = int(len(ys)/2)
    xs[np.arange(len(xs)) &lt; half] *= -1
    np.random.shuffle(xs)
    xs += xcenter
    return xs

def bar(feds, y=&#39;pellets&#39;, stat=&#39;max&#39;, normalize=None, agg=&#39;mean&#39;, var=&#39;std&#39;,
        mixed_align=&#39;raise&#39;, show_individual=False, spread=0.3, positions=None,
        position_labels=None, legend=None, ax=None, output=&#39;plot&#39;, bar_kwargs=None,
        error_kwargs=None, scatter_kwargs=None, **kwargs):
    &#39;&#39;&#39;
    Create a vertical bar chart.

    Parameters
    ----------
    feds : FEDFrame, list-like, or dict
        FED3 data to be plotted.

        - **FEDFrame**: A single line is plotted for this object
        - **list-like**: If a collection of FEDFrames is passed,
        an individual line is plotted for every FEDFrame within `feds`
        - **dict**: If a `dict` is passed, the data are treated as being
        grouped, and average lines are plotted.  The dict should have
        group labels as keys, and FEDFrame objects as values.  Note that
        the values can be either single FEDFrame objects or list-like collections
        of them.  Though if all the values of the `dict` are single FEDFrame
        objects, the data will be treated as if there are no groups.

    y : str, optional
        Metric to plot on y-axis. See `fed3.metrics` or `fed3.metrics.list_metrics()`
        for available options.  The default is &#39;pellets&#39;.
    stat : str or callable, optional
        Function used to collapse time series data to a point value.
        The default is &#39;max&#39;.  With `y=&#39;pellets&#39;`, the maximum of the pellet
        count is plotted.  Other common options would be &#39;mean&#39; or
        &#39;median&#39;.
    normalize : str, optional
        Normalize the values plotted to a time window. The default is None,
        in which case no normalization is done.  For example, using &#39;1H&#39;
        would divide the metric being plotted by the number of hours of
        the FEDFrame.
    agg : str or callable, optional
        How to aggregate the point values being plotted from different FEDs
        when grouping data. The default is &#39;mean&#39;.  Only relevant when
        grouped data are being plotted.
    var : str or callable, optional
        How to show the variation around the bar.  The default is &#39;std&#39;.
    mixed_align : str, optional
        Protocol when encountering FEDFrames with mixed aligment being plotted.
        The default is &#39;raise&#39;.  See `fed3.core.fedfuncs.screen_mixed_alignment()`
        for options.
    show_individual : bool, optional
        When grouping data, show each individual FED&#39;s data as a point floating
        around the bar. The default is False.
    spread : float, optional
        Parameter for controling the spread of points when using `show_individual`.
        The default is 0.3.
    positions : list of int, optional
        List of integers which can be used to determine the position &amp; grouping
        of bars being plotted. The default is None.  Positions should have a length
        equal to the number of bars, and should only contain ascending integers.
        Bars with the same integer label will be grouped side by side.  For example,
        a group of 4 bars could be grouped into sets of 2 with
        `positions=[0, 0, 1, 1]`.  `positions=[0, 1, 2, 3]` would evenly
        space bars (this is the default behavior, set when `None` is passed.)
    position_labels : list of str, optional
        Labels for each position of bars being plotted. The default is None.
    legend : bool or None, optional
        Create a legend. The default is None, in which case follows
        `fed3.plot.OPTIONS[&#39;default_legend&#39;]`.
    ax : matplotlib Axes, optional
        Axes to direct the plotting to. The default is None, in which case
        `plt.gca()` is used.
    output : str, optional
        Specify function behavior and return value. The default is &#39;plot&#39;.

        - **plot**: Plot is created and the matplotlib Figure is returned.
        - **data**: Plot is created, and underlying processed data are returned
        (as a pandas DataFrame).
        - **both**: Plot is created, and the return value is a 2-tuple with
        the first element being the Figure, and second element being the data.
        - **dataonly**: Plot is NOT created; only the processed data are returned.
        - anything else: a `ValueError` is raised.

    bar_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.bar()`.

        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.bar()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.bar()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.

    error_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.errorbar()`.

        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.errorbar()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.errorbar()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.

    scatter_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.scatter()`.

        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.scatter()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.scatter()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.
    **kwargs : dict-like
        Keyword arguments passed to `ax.bar()`.

    Returns
    -------
    variable
        Dependent on parameter `output`.

    &#39;&#39;&#39;

    # parse inputs
    feds_dict = _parse_feds(feds)
    not_group = all(len(f) == 1 for f in feds_dict.values())
    if not_group:
        var = None

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute plot data
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    if normalize is not None:
        metricname += f&#39; ({normalize})&#39;
    DATA = _bar_metric_df(feds_dict, metric=metric, stat=stat,
                          normalize=normalize, agg=agg, var=var)
    individual_data = DATA.iloc[:, :-2]
    barvals = DATA.iloc[:, -2]
    errors = DATA.iloc[:, -1]

    # determine plotting order
    if position_labels is None and positions is None:
        position_labels = feds_dict.keys()
    position_width = 0.75
    centers, positions, bar_widths = _assign_bar_positions_widths(feds,
                                                                  positions,
                                                                  position_width=position_width)

    # update the kwargs to handle individual &amp; general options
    bar_kwargs = {} if bar_kwargs is None else bar_kwargs
    bar_kwargs.update(kwargs) # general kwargs default to bar
    bar_kwargs = _process_plot_kwargs(bar_kwargs, feds_dict.keys())

    error_kwargs = {} if error_kwargs is None else error_kwargs
    error_kwargs = _process_plot_kwargs(error_kwargs, feds_dict.keys())

    scatter_kwargs = {} if scatter_kwargs is None else scatter_kwargs
    scatter_kwargs = _process_plot_kwargs(scatter_kwargs, feds_dict.keys())

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            ax = plt.gca()

        FIG = ax.get_figure()

        for i, label in enumerate(DATA.index):

            # set keyword args for main bar (first plotted)
            this_bar_kwargs = {&#39;label&#39;:label,
                               &#39;zorder&#39;:0,
                               &#39;width&#39;: bar_widths[i]}
            this_bar_kwargs.update(bar_kwargs[label])

            # plot the bars
            x = positions[i]
            y = barvals[i]
            ax.bar(x, y, **this_bar_kwargs)

            # now set keyword args for error, grabbing most recent color
            this_error_kwargs = {&#39;color&#39;:&#39;grey&#39;,
                                 &#39;ls&#39;:&#39;none&#39;,
                                 &#39;capsize&#39;:5,
                                 &#39;zorder&#39;:2}
            this_error_kwargs.update(error_kwargs[label])

            this_scatter_kwargs = {&#39;color&#39;:_get_most_recent_color(ax=ax, kind=&#39;bar&#39;),
                                   &#39;zorder&#39;:1,
                                   &#39;edgecolor&#39;:&#39;k&#39;}
            this_scatter_kwargs.update(scatter_kwargs[label])



            # error bars
            if var is not None:
                err = errors[i]
                ax.errorbar(x=x, y=y, yerr=err, **this_error_kwargs)

            if show_individual:
                w = bar_widths[i] * spread
                ys = individual_data.iloc[i, :].dropna()
                xs = _jitter_ys(ys, x, w)
                ax.scatter(xs, ys, **this_scatter_kwargs)

        # format the axes
        ax.set_ylabel(metricname)
        ax.set_xticks(centers)
        if position_labels is not None:
            ax.set_xticklabels(position_labels)

        legend = OPTIONS[&#39;default_legend&#39;] if legend is None else legend
        if legend:
            ax.legend()

    # output was weird for lists without this step -
    # treated each single FED as group, and created
    # a DF with lots of unhelpful info
    if not_group:
        DATA = DATA.drop(DATA.index, axis=1)
        DATA = DATA.iloc[:, :-1]

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fed3.plot.barchart.bar"><code class="name flex">
<span>def <span class="ident">bar</span></span>(<span>feds, y='pellets', stat='max', normalize=None, agg='mean', var='std', mixed_align='raise', show_individual=False, spread=0.3, positions=None, position_labels=None, legend=None, ax=None, output='plot', bar_kwargs=None, error_kwargs=None, scatter_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a vertical bar chart.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feds</code></strong> :&ensp;<code>FEDFrame, list-like,</code> or <code>dict</code></dt>
<dd>
<p>FED3 data to be plotted.</p>
<ul>
<li><strong>FEDFrame</strong>: A single line is plotted for this object</li>
<li><strong>list-like</strong>: If a collection of FEDFrames is passed,
an individual line is plotted for every FEDFrame within <code>feds</code></li>
<li><strong>dict</strong>: If a <code>dict</code> is passed, the data are treated as being
grouped, and average lines are plotted.
The dict should have
group labels as keys, and FEDFrame objects as values.
Note that
the values can be either single FEDFrame objects or list-like collections
of them.
Though if all the values of the <code>dict</code> are single FEDFrame
objects, the data will be treated as if there are no groups.</li>
</ul>
</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Metric to plot on y-axis. See <code><a title="fed3.metrics" href="../metrics/index.html">fed3.metrics</a></code> or <code><a title="fed3.metrics.list_metrics" href="../metrics/index.html#fed3.metrics.list_metrics">list_metrics()</a></code>
for available options.
The default is 'pellets'.</dd>
<dt><strong><code>stat</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>Function used to collapse time series data to a point value.
The default is 'max'.
With <code>y='pellets'</code>, the maximum of the pellet
count is plotted.
Other common options would be 'mean' or
'median'.</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Normalize the values plotted to a time window. The default is None,
in which case no normalization is done.
For example, using '1H'
would divide the metric being plotted by the number of hours of
the FEDFrame.</dd>
<dt><strong><code>agg</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>How to aggregate the point values being plotted from different FEDs
when grouping data. The default is 'mean'.
Only relevant when
grouped data are being plotted.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>How to show the variation around the bar.
The default is 'std'.</dd>
<dt><strong><code>mixed_align</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Protocol when encountering FEDFrames with mixed aligment being plotted.
The default is 'raise'.
See <code><a title="fed3.core.fedfuncs.screen_mixed_alignment" href="../core/fedfuncs.html#fed3.core.fedfuncs.screen_mixed_alignment">screen_mixed_alignment()</a></code>
for options.</dd>
<dt><strong><code>show_individual</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When grouping data, show each individual FED's data as a point floating
around the bar. The default is False.</dd>
<dt><strong><code>spread</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Parameter for controling the spread of points when using <code>show_individual</code>.
The default is 0.3.</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>list</code> of <code>int</code>, optional</dt>
<dd>List of integers which can be used to determine the position &amp; grouping
of bars being plotted. The default is None.
Positions should have a length
equal to the number of bars, and should only contain ascending integers.
Bars with the same integer label will be grouped side by side.
For example,
a group of 4 bars could be grouped into sets of 2 with
<code>positions=[0, 0, 1, 1]</code>.
<code>positions=[0, 1, 2, 3]</code> would evenly
space bars (this is the default behavior, set when <code>None</code> is passed.)</dd>
<dt><strong><code>position_labels</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>Labels for each position of bars being plotted. The default is None.</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code> or <code>None</code>, optional</dt>
<dd>Create a legend. The default is None, in which case follows
<code>fed3.plot.OPTIONS['default_legend']</code>.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axes</code>, optional</dt>
<dd>Axes to direct the plotting to. The default is None, in which case
<code>plt.gca()</code> is used.</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Specify function behavior and return value. The default is 'plot'.</p>
<ul>
<li><strong>plot</strong>: Plot is created and the matplotlib Figure is returned.</li>
<li><strong>data</strong>: Plot is created, and underlying processed data are returned
(as a pandas DataFrame).</li>
<li><strong>both</strong>: Plot is created, and the return value is a 2-tuple with
the first element being the Figure, and second element being the data.</li>
<li><strong>dataonly</strong>: Plot is NOT created; only the processed data are returned.</li>
<li>anything else: a <code>ValueError</code> is raised.</li>
</ul>
</dd>
<dt><strong><code>bar_kwargs</code></strong> :&ensp;<code>dict-like</code>, optional</dt>
<dd>
<p>Dictionary for providing kwargs to matplotlib, specifically <code>ax.bar()</code>.</p>
<ul>
<li>If the dictionary key corresponds to the name of a FEDFrame being plotted,
or the name of a group of FEDFrames being plotted, then the value
should be another dictionary mapping keyword arguments for <code>ax.bar()</code>
to their values.</li>
<li>Otherwise, the keys are assumed to be keywords arguments for <code>ax.bar()</code>,
and values are the argument values.
In this case, the kwargs are applied
to all lines being plotted.</li>
</ul>
</dd>
<dt><strong><code>error_kwargs</code></strong> :&ensp;<code>dict-like</code>, optional</dt>
<dd>
<p>Dictionary for providing kwargs to matplotlib, specifically <code>ax.errorbar()</code>.</p>
<ul>
<li>If the dictionary key corresponds to the name of a FEDFrame being plotted,
or the name of a group of FEDFrames being plotted, then the value
should be another dictionary mapping keyword arguments for <code>ax.errorbar()</code>
to their values.</li>
<li>Otherwise, the keys are assumed to be keywords arguments for <code>ax.errorbar()</code>,
and values are the argument values.
In this case, the kwargs are applied
to all lines being plotted.</li>
</ul>
</dd>
<dt><strong><code>scatter_kwargs</code></strong> :&ensp;<code>dict-like</code>, optional</dt>
<dd>
<p>Dictionary for providing kwargs to matplotlib, specifically <code>ax.scatter()</code>.</p>
<ul>
<li>If the dictionary key corresponds to the name of a FEDFrame being plotted,
or the name of a group of FEDFrames being plotted, then the value
should be another dictionary mapping keyword arguments for <code>ax.scatter()</code>
to their values.</li>
<li>Otherwise, the keys are assumed to be keywords arguments for <code>ax.scatter()</code>,
and values are the argument values.
In this case, the kwargs are applied
to all lines being plotted.</li>
</ul>
</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict-like</code></dt>
<dd>Keyword arguments passed to <code>ax.bar()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>variable</code></dt>
<dd>Dependent on parameter <code>output</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bar(feds, y=&#39;pellets&#39;, stat=&#39;max&#39;, normalize=None, agg=&#39;mean&#39;, var=&#39;std&#39;,
        mixed_align=&#39;raise&#39;, show_individual=False, spread=0.3, positions=None,
        position_labels=None, legend=None, ax=None, output=&#39;plot&#39;, bar_kwargs=None,
        error_kwargs=None, scatter_kwargs=None, **kwargs):
    &#39;&#39;&#39;
    Create a vertical bar chart.

    Parameters
    ----------
    feds : FEDFrame, list-like, or dict
        FED3 data to be plotted.

        - **FEDFrame**: A single line is plotted for this object
        - **list-like**: If a collection of FEDFrames is passed,
        an individual line is plotted for every FEDFrame within `feds`
        - **dict**: If a `dict` is passed, the data are treated as being
        grouped, and average lines are plotted.  The dict should have
        group labels as keys, and FEDFrame objects as values.  Note that
        the values can be either single FEDFrame objects or list-like collections
        of them.  Though if all the values of the `dict` are single FEDFrame
        objects, the data will be treated as if there are no groups.

    y : str, optional
        Metric to plot on y-axis. See `fed3.metrics` or `fed3.metrics.list_metrics()`
        for available options.  The default is &#39;pellets&#39;.
    stat : str or callable, optional
        Function used to collapse time series data to a point value.
        The default is &#39;max&#39;.  With `y=&#39;pellets&#39;`, the maximum of the pellet
        count is plotted.  Other common options would be &#39;mean&#39; or
        &#39;median&#39;.
    normalize : str, optional
        Normalize the values plotted to a time window. The default is None,
        in which case no normalization is done.  For example, using &#39;1H&#39;
        would divide the metric being plotted by the number of hours of
        the FEDFrame.
    agg : str or callable, optional
        How to aggregate the point values being plotted from different FEDs
        when grouping data. The default is &#39;mean&#39;.  Only relevant when
        grouped data are being plotted.
    var : str or callable, optional
        How to show the variation around the bar.  The default is &#39;std&#39;.
    mixed_align : str, optional
        Protocol when encountering FEDFrames with mixed aligment being plotted.
        The default is &#39;raise&#39;.  See `fed3.core.fedfuncs.screen_mixed_alignment()`
        for options.
    show_individual : bool, optional
        When grouping data, show each individual FED&#39;s data as a point floating
        around the bar. The default is False.
    spread : float, optional
        Parameter for controling the spread of points when using `show_individual`.
        The default is 0.3.
    positions : list of int, optional
        List of integers which can be used to determine the position &amp; grouping
        of bars being plotted. The default is None.  Positions should have a length
        equal to the number of bars, and should only contain ascending integers.
        Bars with the same integer label will be grouped side by side.  For example,
        a group of 4 bars could be grouped into sets of 2 with
        `positions=[0, 0, 1, 1]`.  `positions=[0, 1, 2, 3]` would evenly
        space bars (this is the default behavior, set when `None` is passed.)
    position_labels : list of str, optional
        Labels for each position of bars being plotted. The default is None.
    legend : bool or None, optional
        Create a legend. The default is None, in which case follows
        `fed3.plot.OPTIONS[&#39;default_legend&#39;]`.
    ax : matplotlib Axes, optional
        Axes to direct the plotting to. The default is None, in which case
        `plt.gca()` is used.
    output : str, optional
        Specify function behavior and return value. The default is &#39;plot&#39;.

        - **plot**: Plot is created and the matplotlib Figure is returned.
        - **data**: Plot is created, and underlying processed data are returned
        (as a pandas DataFrame).
        - **both**: Plot is created, and the return value is a 2-tuple with
        the first element being the Figure, and second element being the data.
        - **dataonly**: Plot is NOT created; only the processed data are returned.
        - anything else: a `ValueError` is raised.

    bar_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.bar()`.

        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.bar()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.bar()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.

    error_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.errorbar()`.

        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.errorbar()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.errorbar()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.

    scatter_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.scatter()`.

        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.scatter()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.scatter()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.
    **kwargs : dict-like
        Keyword arguments passed to `ax.bar()`.

    Returns
    -------
    variable
        Dependent on parameter `output`.

    &#39;&#39;&#39;

    # parse inputs
    feds_dict = _parse_feds(feds)
    not_group = all(len(f) == 1 for f in feds_dict.values())
    if not_group:
        var = None

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute plot data
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    if normalize is not None:
        metricname += f&#39; ({normalize})&#39;
    DATA = _bar_metric_df(feds_dict, metric=metric, stat=stat,
                          normalize=normalize, agg=agg, var=var)
    individual_data = DATA.iloc[:, :-2]
    barvals = DATA.iloc[:, -2]
    errors = DATA.iloc[:, -1]

    # determine plotting order
    if position_labels is None and positions is None:
        position_labels = feds_dict.keys()
    position_width = 0.75
    centers, positions, bar_widths = _assign_bar_positions_widths(feds,
                                                                  positions,
                                                                  position_width=position_width)

    # update the kwargs to handle individual &amp; general options
    bar_kwargs = {} if bar_kwargs is None else bar_kwargs
    bar_kwargs.update(kwargs) # general kwargs default to bar
    bar_kwargs = _process_plot_kwargs(bar_kwargs, feds_dict.keys())

    error_kwargs = {} if error_kwargs is None else error_kwargs
    error_kwargs = _process_plot_kwargs(error_kwargs, feds_dict.keys())

    scatter_kwargs = {} if scatter_kwargs is None else scatter_kwargs
    scatter_kwargs = _process_plot_kwargs(scatter_kwargs, feds_dict.keys())

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            ax = plt.gca()

        FIG = ax.get_figure()

        for i, label in enumerate(DATA.index):

            # set keyword args for main bar (first plotted)
            this_bar_kwargs = {&#39;label&#39;:label,
                               &#39;zorder&#39;:0,
                               &#39;width&#39;: bar_widths[i]}
            this_bar_kwargs.update(bar_kwargs[label])

            # plot the bars
            x = positions[i]
            y = barvals[i]
            ax.bar(x, y, **this_bar_kwargs)

            # now set keyword args for error, grabbing most recent color
            this_error_kwargs = {&#39;color&#39;:&#39;grey&#39;,
                                 &#39;ls&#39;:&#39;none&#39;,
                                 &#39;capsize&#39;:5,
                                 &#39;zorder&#39;:2}
            this_error_kwargs.update(error_kwargs[label])

            this_scatter_kwargs = {&#39;color&#39;:_get_most_recent_color(ax=ax, kind=&#39;bar&#39;),
                                   &#39;zorder&#39;:1,
                                   &#39;edgecolor&#39;:&#39;k&#39;}
            this_scatter_kwargs.update(scatter_kwargs[label])



            # error bars
            if var is not None:
                err = errors[i]
                ax.errorbar(x=x, y=y, yerr=err, **this_error_kwargs)

            if show_individual:
                w = bar_widths[i] * spread
                ys = individual_data.iloc[i, :].dropna()
                xs = _jitter_ys(ys, x, w)
                ax.scatter(xs, ys, **this_scatter_kwargs)

        # format the axes
        ax.set_ylabel(metricname)
        ax.set_xticks(centers)
        if position_labels is not None:
            ax.set_xticklabels(position_labels)

        legend = OPTIONS[&#39;default_legend&#39;] if legend is None else legend
        if legend:
            ax.legend()

    # output was weird for lists without this step -
    # treated each single FED as group, and created
    # a DF with lots of unhelpful info
    if not_group:
        DATA = DATA.drop(DATA.index, axis=1)
        DATA = DATA.iloc[:, :-1]

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#bar-charts">Bar charts</a><ul>
<li><a href="#basic-bar-charts">Basic bar charts</a><ul>
<li><a href="#positioning-bars">Positioning bars</a></li>
</ul>
</li>
<li><a href="#grouping-data">Grouping data</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fed3.plot" href="index.html">fed3.plot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fed3.plot.barchart.bar" href="#fed3.plot.barchart.bar">bar</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>