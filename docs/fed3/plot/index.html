<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fed3.plot API documentation</title>
<meta name="description" content="Plotting with fed3 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fed3.plot</code></h1>
</header>
<section id="section-intro">
<h1 id="plotting-with-fed3">Plotting with fed3</h1>
<h2 id="import-fed3plot">Import <code><a title="fed3.plot" href="#fed3.plot">fed3.plot</a></code></h2>
<p>The plotting package within fed3, <code><a title="fed3.plot" href="#fed3.plot">fed3.plot</a></code> is not imported by default.
Make an explicit call to import it:</p>
<pre><code class="python">import fed3
import fed3.plot as fplot
</code></pre>
<p>For the purposes of this documentation, matplotlib will be used to set the default figure size.</p>
<pre><code class="python">import matplotlib
matplotlib.rcParams['figure.figsize'] = [7, 5]
matplotlib.rcParams['figure.dpi'] = 100
</code></pre>
<h2 id="example-data">Example data</h2>
<p>The following sections will make use of some example data, provided by the <a href="https://earnestt1234.github.io/fed3/fed3/examples/index.html"><code>fed3.examples</code></a> package:</p>
<pre><code class="python">fedlist = fed3.load_examples('justin')
f = fedlist[0]
</code></pre>
<h2 id="basic-plotting">Basic plotting</h2>
<p>The following section will intoduce the basics of plotting with fed3.
</p>
<h3 id="the-hello-world-plot">The "Hello World" plot</h3>
<p>The simplest plot is the <a href="https://earnestt1234.github.io/fed3/fed3/plot/simple.html#fed3.plot.simple.line">line plot</a>, which plots a variable of interest over time.
This demonstrates the syntax that applies to almost all plotting functions: pass the data to be plotted as the first argument (the FEDFrame(s)) followed by any options.
In this case, the <code>y</code> parameter specifies the variable to be plotted: </p>
<pre><code class="python">fig = fplot.line(feds=f, y='pellets')
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/plots_docs/img/plots_getting_started/plots_getting_started_9_0.png"></p>
<p>Many other <code>y</code> values can be specified - they link to the functions defined within <a href="https://earnestt1234.github.io/fed3/fed3/metrics/index.html"><code>fed3.metrics</code></a>.
Call <a href="https://earnestt1234.github.io/fed3/fed3/index.html#fed3.list_metrics"><code>fed3.list_metrics()</code></a> to see all available options.</p>
<h3 id="plotting-multiple-feds">Plotting multiple FEDs</h3>
<p>Most plots are able to plot data from multiple FEDs, either as separate or aggregated curves.
The structure of the passed data determines this behavior:</p>
<ul>
<li>A single FEDFrame (<a href="https://earnestt1234.github.io/fed3/fed3/core/fedframe.html#fed3.core.fedframe.FEDFrame"><code>fed3.core.fedframe.FEDFrame</code></a>) specifies a single line to be plotted (as shown above)</li>
<li>A <code>list</code> (or other 1D collection) of FEDFrames will plot each as separate curves</li>
<li>A <code>dict</code> is used to aggregate data.
Within each dictionary, the key is the group label, and the value is the collection of FEDFrames belonging to that group.</li>
</ul>
<p>The following is an example of the second option - data for each FED are </p>
<pre><code class="python">fig = fplot.line(feds=fedlist, y='pellets')
</code></pre>
<p><img alt="png" src="https://raw.githubusercontent.com/earnestt1234/fed3/plots_docs/img/plots_getting_started/plots_getting_started_12_0.png"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

&#39;&#39;&#39;
.. include:: ../../docs/plots_getting_started.md
&#39;&#39;&#39;

# color cycle
import matplotlib.pyplot as plt

prop_cycle = plt.rcParams[&#39;axes.prop_cycle&#39;]
COLORCYCLE = list(prop_cycle.by_key()[&#39;color&#39;])

def set_colorcycle(colors):
    COLORCYCLE[:] = list(colors)

#imports for package namespace

from .barchart import bar
from .chronogram import (chronogram_circle, chronogram_line, chronogram_spiny)
from .ipi import (ipi)
from .simple import (line, scatter)

__all__ = [&#39;COLORCYCLE&#39;,
           &#39;bar&#39;,
           &#39;chronogram_circle&#39;,
           &#39;chronogram_line&#39;,
           &#39;chronogram_spiny&#39;,
           &#39;ipi&#39;,
           &#39;line&#39;,
           &#39;scatter&#39;,
           &#39;set_colorcycle&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fed3.plot.barchart" href="barchart.html">fed3.plot.barchart</a></code></dt>
<dd>
<div class="desc"><p>Created on Sun May 29 20:31:41 2022 â€¦</p></div>
</dd>
<dt><code class="name"><a title="fed3.plot.chronogram" href="chronogram.html">fed3.plot.chronogram</a></code></dt>
<dd>
<div class="desc"><p>Created on Tue Apr
5 17:40:10 2022 â€¦</p></div>
</dd>
<dt><code class="name"><a title="fed3.plot.format_axis" href="format_axis.html">fed3.plot.format_axis</a></code></dt>
<dd>
<div class="desc"><p>Created on Sun May
9 15:24:38 2021 â€¦</p></div>
</dd>
<dt><code class="name"><a title="fed3.plot.helpers" href="helpers.html">fed3.plot.helpers</a></code></dt>
<dd>
<div class="desc"><p>Created on Wed Feb
2 12:34:52 2022 â€¦</p></div>
</dd>
<dt><code class="name"><a title="fed3.plot.shadedark" href="shadedark.html">fed3.plot.shadedark</a></code></dt>
<dd>
<div class="desc"><p>Created on Sun May
9 15:26:30 2021 â€¦</p></div>
</dd>
<dt><code class="name"><a title="fed3.plot.simple" href="simple.html">fed3.plot.simple</a></code></dt>
<dd>
<div class="desc"><p>Created on Fri Apr 30 18:06:53 2021 â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fed3.plot.bar"><code class="name flex">
<span>def <span class="ident">bar</span></span>(<span>feds, y='pellets', stat='max', normalize=None, agg='mean', var='std', mixed_align='raise', show_individual=True, spread=0.3, positions=None, position_labels=None, legend=True, ax=None, output='plot', bar_kwargs=None, error_kwargs=None, scatter_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bar(feds, y=&#39;pellets&#39;, stat=&#39;max&#39;, normalize=None, agg=&#39;mean&#39;, var=&#39;std&#39;,
        mixed_align=&#39;raise&#39;, show_individual=True, spread=0.3, positions=None,
        position_labels=None, legend=True, ax=None, output=&#39;plot&#39;, bar_kwargs=None,
        error_kwargs=None, scatter_kwargs=None, **kwargs):

    # parse inputs
    feds_dict = _parse_feds(feds)

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute plot data
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    if normalize is not None:
        metricname += f&#39; ({normalize})&#39;
    DATA = _bar_metric_df(feds_dict, metric=metric, stat=stat,
                          normalize=normalize, agg=agg, var=var)
    individual_data = DATA.iloc[:, :-2]
    barvals = DATA.iloc[:, -2]
    errors = DATA.iloc[:, -1]

    # determine plotting order
    if position_labels is None and positions is None:
        position_labels = feds_dict.keys()
    position_width = 0.75
    centers, positions, bar_widths = _assign_bar_positions_widths(feds,
                                                                  positions,
                                                                  position_width=position_width)

    # update the kwargs to handle individual &amp; general options
    bar_kwargs = {} if bar_kwargs is None else bar_kwargs
    bar_kwargs.update(kwargs) # general kwargs default to bar
    bar_kwargs = _process_plot_kwargs(bar_kwargs, feds_dict.keys())

    error_kwargs = {} if error_kwargs is None else error_kwargs
    error_kwargs = _process_plot_kwargs(error_kwargs, feds_dict.keys())

    scatter_kwargs = {} if scatter_kwargs is None else scatter_kwargs
    scatter_kwargs = _process_plot_kwargs(scatter_kwargs, feds_dict.keys())

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            ax = plt.gca()

        FIG = ax.get_figure()

        for i, label in enumerate(DATA.index):

            # set keyword args passed
            this_bar_kwargs = {&#39;color&#39;:COLORCYCLE[i],
                               &#39;label&#39;:label,
                               &#39;zorder&#39;:0,
                               &#39;width&#39;: bar_widths[i]}
            this_bar_kwargs.update(bar_kwargs[label])

            this_error_kwargs = {&#39;color&#39;:&#39;grey&#39;,
                                 &#39;ls&#39;:&#39;none&#39;,
                                 &#39;capsize&#39;:5,
                                 &#39;zorder&#39;:2}
            this_error_kwargs.update(error_kwargs[label])

            this_scatter_kwargs = {&#39;color&#39;:COLORCYCLE[i],
                                   &#39;zorder&#39;:1,
                                   &#39;edgecolor&#39;:&#39;k&#39;}
            this_scatter_kwargs.update(scatter_kwargs[label])

            # plot the bars
            x = positions[i]
            y = barvals[i]
            ax.bar(x, y, **this_bar_kwargs)

            # error bars
            if var is not None:
                err = errors[i]
                ax.errorbar(x=x, y=y, yerr=err, **this_error_kwargs)

            if show_individual:
                w = bar_widths[i] * spread
                ys = individual_data.iloc[i, :].dropna()
                xs = _jitter_ys(ys, x, w)
                ax.scatter(xs, ys, **this_scatter_kwargs)

    # format the axes
    ax.set_ylabel(metricname)
    ax.set_xticks(centers)
    if position_labels is not None:
        ax.set_xticklabels(position_labels)

    if legend:
        ax.legend()

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</dd>
<dt id="fed3.plot.chronogram_circle"><code class="name flex">
<span>def <span class="ident">chronogram_circle</span></span>(<span>feds, y='pellets', bins='1H', agg='mean', var='std', mixed_align='raise', output='plot', shadedark=True, ax=None, legend=True, line_kwargs=None, error_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chronogram_circle(feds, y=&#39;pellets&#39;, bins=&#39;1H&#39;, agg=&#39;mean&#39;, var=&#39;std&#39;,
                      mixed_align=&#39;raise&#39;, output=&#39;plot&#39;,
                      shadedark=True, ax=None, legend=True,
                      line_kwargs=None, error_kwargs=None, **kwargs):

    # parse input
    feds_dict = _parse_feds(feds)
    is_group = any(len(v) &gt; 1 for v in feds_dict.values())
    var = var if is_group else None

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute data
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    AGGDATA, VARDATA = _create_group_chronogram_df(feds=feds_dict, metric=metric, bins=bins,
                                                   agg=agg, var=var, origin_lightcycle=True,
                                                   reorder_index=True, relative_index=True)

    # create return data
    if var is None:
        DATA = AGGDATA
    else:
        lsuffix = f&#34;_{agg}&#34; if isinstance(agg, str) else &#34;_agg&#34;
        rsuffix = f&#34;_{var}&#34; if isinstance(var, str) else &#34;_var&#34;
        DATA = AGGDATA.join(VARDATA, how=&#39;outer&#39;, lsuffix=lsuffix, rsuffix=rsuffix)

    # update the kwargs to handle individual &amp; general options
    line_kwargs = {} if line_kwargs is None else line_kwargs
    line_kwargs.update(kwargs) # general kwargs default to updatine line
    line_kwargs = _process_plot_kwargs(line_kwargs, feds_dict.keys())

    error_kwargs = {} if error_kwargs is None else error_kwargs
    error_kwargs = _process_plot_kwargs(error_kwargs, feds_dict.keys())

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            fig, ax = plt.subplots(subplot_kw=dict(polar=True))
        ax.set_theta_zero_location(&#34;N&#34;)
        ax.set_theta_direction(-1)

        FIG = ax.get_figure()

        # plot group level data
        for i, col in enumerate(AGGDATA.columns):

            # set keyword args passed
            this_kwargs = {}
            this_kwargs[&#39;color&#39;] = COLORCYCLE[i]
            this_kwargs[&#39;label&#39;] = col
            this_kwargs.update(line_kwargs[col])

            this_error_kwargs = {}
            this_error_kwargs[&#39;color&#39;] = COLORCYCLE[i]
            this_error_kwargs[&#39;alpha&#39;] = 0.3
            this_error_kwargs.update(error_kwargs[col])

            # plot
            y = AGGDATA[col]
            y = np.append(y, y[0])
            x = np.linspace(0, 2*np.pi, len(y))
            ax.plot(x, y, **this_kwargs)

            # plot error
            if not VARDATA.empty:

                y = AGGDATA[col]
                y = np.append(y, y[0])
                v = VARDATA[col]
                v = np.append(v, v[0])
                x = np.linspace(0, 2*np.pi, len(y))

                ax.fill_between(x, y-v, y+v, **this_error_kwargs)

            # plot individual lines
            if var == &#39;raw&#39;:

                group_feds = feds_dict[col]
                metric_df = _create_chronogram_df(feds=group_feds,
                                                  metric=metric,
                                                  bins=bins,
                                                  origin_lightcycle=True,
                                                  reorder_index=True,
                                                  relative_index=True)
                for col in metric_df.columns:
                    y = metric_df[col]
                    y = np.append(y, y[0])
                    x = np.linspace(0, 2*np.pi, len(y))
                    ax.plot(x, y, **this_error_kwargs)

        # axis level formatting
        ax.set_xlabel(&#34;Hour of Light Cycle&#34;)
        ax.set_xticks(np.linspace(0, 2*np.pi, 5))
        ax.set_xticklabels([0, 6, 12, 18, None])
        ax.set_title(metricname, pad=10)

        if shadedark:
            on, off = LIGHTCYCLE[&#39;on&#39;], LIGHTCYCLE[&#39;off&#39;]
            on = time_to_float(on)
            off = time_to_float(off)
            off += (on &gt; off) * 24
            start = off - on
            theta = (start / 24) * 2 * np.pi
            ax.fill_between(np.linspace(theta, 2*np.pi, 100), 0, ax.get_rmax(),
                            color=&#39;gray&#39;,alpha=.2,zorder=0,label=&#39;lights off&#39;)

        if legend:
            ax.legend()

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</dd>
<dt id="fed3.plot.chronogram_line"><code class="name flex">
<span>def <span class="ident">chronogram_line</span></span>(<span>feds, y='pellets', bins='15T', agg='mean', var='std', mixed_align='raise', output='plot', shadedark=True, ax=None, legend=True, line_kwargs=None, error_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chronogram_line(feds, y=&#39;pellets&#39;, bins=&#39;15T&#39;, agg=&#39;mean&#39;, var=&#39;std&#39;,
                    mixed_align=&#39;raise&#39;, output=&#39;plot&#39;,
                    shadedark=True, ax=None, legend=True,
                    line_kwargs=None, error_kwargs=None, **kwargs):

    # parse input
    feds_dict = _parse_feds(feds)
    is_group = any(len(v) &gt; 1 for v in feds_dict.values())
    var = var if is_group else None

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute data
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    AGGDATA, VARDATA = _create_group_chronogram_df(feds=feds_dict, metric=metric, bins=bins,
                                                   agg=agg, var=var, origin_lightcycle=True,
                                                   reorder_index=True, relative_index=True)

    # create return data
    if var is None:
        DATA = AGGDATA
    else:
        lsuffix = f&#34;_{agg}&#34; if isinstance(agg, str) else &#34;_agg&#34;
        rsuffix = f&#34;_{var}&#34; if isinstance(var, str) else &#34;_var&#34;
        DATA = AGGDATA.join(VARDATA, how=&#39;outer&#39;, lsuffix=lsuffix, rsuffix=rsuffix)

    # update the kwargs to handle individual &amp; general options
    line_kwargs = {} if line_kwargs is None else line_kwargs
    line_kwargs.update(kwargs) # general kwargs default to updatine line
    line_kwargs = _process_plot_kwargs(line_kwargs, feds_dict.keys())

    error_kwargs = {} if error_kwargs is None else error_kwargs
    error_kwargs = _process_plot_kwargs(error_kwargs, feds_dict.keys())

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            ax = plt.gca()

        FIG = ax.get_figure()

        # plot group level data
        for i, col in enumerate(AGGDATA.columns):

            # set keyword args passed
            this_kwargs = {}
            this_kwargs[&#39;color&#39;] = COLORCYCLE[i]
            this_kwargs[&#39;label&#39;] = col
            this_kwargs.update(line_kwargs[col])

            this_error_kwargs = {}
            this_error_kwargs[&#39;color&#39;] = COLORCYCLE[i]
            this_error_kwargs[&#39;alpha&#39;] = 0.3
            this_error_kwargs.update(error_kwargs[col])

            # plot
            y = AGGDATA[col]
            x = AGGDATA.index
            ax.plot(x, y, **this_kwargs)

            # plot error
            if not VARDATA.empty:
                y = AGGDATA[col]
                x = y.index
                v = VARDATA[col]
                ax.fill_between(x, y-v, y+v, **this_error_kwargs)

            # plot individual lines
            if var == &#39;raw&#39;:

                group_feds = feds_dict[col]
                metric_df = _create_chronogram_df(feds=group_feds,
                                                  metric=metric,
                                                  bins=bins,
                                                  origin_lightcycle=True,
                                                  reorder_index=True,
                                                  relative_index=True)
                for col in metric_df.columns:
                    y = metric_df[col]
                    x = y.index
                    ax.plot(x, y, **this_error_kwargs)

        # axis level formatting
        ax.set_ylabel(metricname)
        ax.set_xlabel(&#34;Hour of Light Cycle&#34;)

        ax.set_xticks([0, 6, 12, 18, 24])

        if shadedark:
            on, off = LIGHTCYCLE[&#39;on&#39;], LIGHTCYCLE[&#39;off&#39;]
            on = time_to_float(on)
            off = time_to_float(off)
            off += (on &gt; off) * 24
            start = off - on
            ax.axvspan(start, 24, color=&#39;gray&#39;, alpha=.2, zorder=0, label=&#39;lights off&#39;)

        if legend:
            ax.legend(bbox_to_anchor=(1,1), loc=&#39;upper left&#39;)

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</dd>
<dt id="fed3.plot.chronogram_spiny"><code class="name flex">
<span>def <span class="ident">chronogram_spiny</span></span>(<span>feds, y='pellets', bins='15T', agg='mean', mixed_align='raise', output='plot', shadedark=True, ax=None, legend=True, plot_quick=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chronogram_spiny(feds, y=&#39;pellets&#39;, bins=&#39;15T&#39;, agg=&#39;mean&#39;,
                     mixed_align=&#39;raise&#39;, output=&#39;plot&#39;,
                     shadedark=True, ax=None, legend=True,
                     plot_quick=True, **kwargs):

    # handle parsing here, to only accept single groups
    feds_dict = _parse_feds_spiny_chronogram(feds)

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute data
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    DATA, _ = _create_group_chronogram_df(feds=feds_dict, metric=metric, bins=bins,
                                          agg=agg, var=None, origin_lightcycle=True,
                                          reorder_index=True, relative_index=True)

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            FIG, ax = plt.subplots(subplot_kw=dict(polar=True))
        ax.set_theta_zero_location(&#34;N&#34;)
        ax.set_theta_direction(-1)

        FIG = ax.get_figure()

        # set keyword args passed
        kwargs[&#39;color&#39;] = &#39;crimson&#39; if not kwargs.get(&#39;color&#39;) else kwargs.get(&#39;color&#39;)

        # plot
        if plot_quick:
            y = list(DATA.iloc[:, 0]) + [0]
            x = np.linspace(0, 2*np.pi, len(y))
            x, y = _spine_data_trick(x, y)
            ax.plot(x, y, **kwargs)
        else:
            y = DATA.iloc[:, 0]
            x = np.linspace(0, 2*np.pi, len(y)+1)
            for n, val in enumerate(y):
                label = n * &#39;_&#39; + DATA.columns[0]
                ax.plot([0, x[n]], [0, val], label=label, **kwargs)

        # axis level formatting
        ax.set_xlabel(&#34;Hour of Light Cycle&#34;)
        ax.set_xticks(np.linspace(0, 2*np.pi, 5))
        ax.set_xticklabels([0, 6, 12, 18, None])
        ax.set_title(metricname, pad=10)

        if shadedark:
            on, off = LIGHTCYCLE[&#39;on&#39;], LIGHTCYCLE[&#39;off&#39;]
            on = time_to_float(on)
            off = time_to_float(off)
            off += (on &gt; off) * 24
            start = off - on
            theta = (start / 24) * 2 * np.pi
            ax.fill_between(np.linspace(theta, 2*np.pi, 100), 0, ax.get_rmax(),
                            color=&#39;gray&#39;,alpha=.2,zorder=0,label=&#39;lights off&#39;)

        if legend:
            ax.legend(bbox_to_anchor=(1,1), loc=&#39;upper left&#39;)

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</dd>
<dt id="fed3.plot.ipi"><code class="name flex">
<span>def <span class="ident">ipi</span></span>(<span>feds, logx=True, kde=True, mixed_align='raise', output='plot', ax=None, legend=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ipi(feds, logx=True, kde=True, mixed_align=&#39;raise&#39;, output=&#39;plot&#39;,
        ax=None, legend=True, **kwargs):

    # set the outputs
    FIG = None
    DATA = pd.DataFrame()

    # setup input arguments
    feds_dict = _parse_feds(feds)
    is_group = any(len(v) &gt; 1 for v in feds_dict.values())
    feds_all = []
    for l in feds_dict.values():
        feds_all += l

    # screen issues alignment
    alignment = screen_mixed_alignment(feds_all, option=mixed_align)

    # compute data for individual feds
    y = &#39;ipi&#39;
    metric_obj = get_metric(y)
    metric = metric_obj.func
    metricname = metric_obj.nicename
    DATA = _create_metric_df(feds=feds_all, metric=metric)
    if is_group:
        DATA = _stack_group_values(DATA, feds_dict)

    # handle plot creation and returns
    if output in [&#39;plot&#39;, &#39;data&#39;, &#39;both&#39;]:

        if ax is None:
            ax = plt.gca()

        FIG = _plot_hist_data(ax=ax,
                              data=DATA,
                              logx=logx,
                              kde=kde,
                              legend=legend,
                              **kwargs)

        ax.set_xlabel(metricname)

    return _get_return_value(FIG=FIG, DATA=DATA, output=output)</code></pre>
</details>
</dd>
<dt id="fed3.plot.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>feds, y='pellets', bins=None, agg='mean', var='std', omit_na=False, mixed_align='raise', output='plot', xaxis='auto', shadedark=True, ax=None, legend=True, line_kwargs=None, error_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a line plot, with time on the x-axis and a variable
of interest on the y-axis.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feds</code></strong> :&ensp;<code>FEDFrame, list-like,</code> or <code>dict</code></dt>
<dd>FED3 data to be plotted.
- <strong>FEDFrame</strong>: A single line is plotted for this object
- <strong>list-like</strong>: If a collection of FEDFrames is passed,
an individual line is plotted for every FEDFrame within <code>feds</code>
- <strong>dict</strong>: If a <code>dict</code> is passed, the data are treated as being
grouped, and average lines are plotted.
The dict should have
group labels as keys, and FEDFrame objects as values.
Note that
the values can be either single FEDFrame objects or list-like collections
of them.
Though if all the values of the <code>dict</code> are single FEDFrame
objects, the data will be treated as if there are no groups.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Metric to plot on y-axis. See <code><a title="fed3.metrics" href="../metrics/index.html">fed3.metrics</a></code> or <code><a title="fed3.metrics.list_metrics" href="../metrics/index.html#fed3.metrics.list_metrics">list_metrics()</a></code>
for available options.
The default is 'pellets'.</dd>
<dt><strong><code>bins</code></strong> :&ensp;<code>pandas time offset string</code>, optional</dt>
<dd>Frequency string denoting how data should be binned when plotting.
The default is None, in which case there is no binnings.
Examples
are '1H' for 1 hour or '15T' for 15 minutes.
When group data are passed
(see <code>feds</code>) and <code>bins</code> is not specified, defaults to <code>1H</code>.</dd>
<dt><strong><code>agg</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>Function to aggregate data from multiple FEDFrames in a group (for each
temporal bin).
The default is 'mean'.
Only relevant when grouped
data are being plotted.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code> or <code>callable</code>, optional</dt>
<dd>Function to measure variation of data from multiple FEDFrames in a group
(for each temporal bin).
The default is 'std'.
The output of this
callable is represented as a shaded error bar around the line.
Only relevant when grouped data are being plotted. The default is 'std'.</dd>
<dt><strong><code>omit_na</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True, omits bins in a group where at least one FEDFrame has
missing data. Only relevant when grouped data are being plotted.
The default is False.</dd>
<dt><strong><code>mixed_align</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Protocol when encountering FEDFrames with mixed aligment being plotted.
The default is 'raise'.
See <code><a title="fed3.core.fedfuncs.screen_mixed_alignment" href="../core/fedfuncs.html#fed3.core.fedfuncs.screen_mixed_alignment">screen_mixed_alignment()</a></code>
for options.</dd>
<dt><strong><code>output</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Specify function behavior and return value. The default is 'plot'.
- <strong>plot</strong>: Plot is created and the matplotlib Figure is returned.
- <strong>data</strong>: Plot is created, and underlying processed data are returned
(as a pandas DataFrame).
- <strong>both</strong>: Plot is created, and the return value is a 2-tuple with
the first element being the Figure, and second element being the data.
- <strong>dataonly</strong>: Plot is NOT created; only the processed data are returned.
- anything else: a <code>ValueError</code> is raised.</dd>
<dt><strong><code>xaxis</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>X-axis type to used for plotting. This is usually determined by the
alignment of the FEDFrames, and should be handled by 'auto' (default).
Other options are 'datetime', 'time', and 'elapsed'.</dd>
<dt><strong><code>shadedark</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When applicable based on the FEDFrame alignment, create shaded
boxes indicating when the lights were off. The default is True.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib Axes</code>, optional</dt>
<dd>Axes to direct the plotting to. The default is None, in which case
<code>plt.gca()</code> is used.</dd>
<dt><strong><code>legend</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Create a legend. The default is True.</dd>
<dt><strong><code>line_kwargs</code></strong> :&ensp;<code>dict-like</code>, optional</dt>
<dd>Dictionary for providing kwargs to matplotlib, specifically <code>ax.plot()</code>.
- If the dictionary key corresponds to the name of a FEDFrame being plotted,
or the name of a group of FEDFrames being plotted, then the value
should be another dictionary mapping keyword arguments for <code>ax.plot()</code>
to their values.
- Otherwise, the keys are assumed to be keywords arguments for <code>ax.plot()</code>,
and values are the argument values.
In this case, the kwargs are applied
to all lines being plotted.</dd>
<dt><strong><code>error_kwargs</code></strong> :&ensp;<code>dict-like</code>, optional</dt>
<dd>Dictionary for providing kwargs to matplotlib, specifically <code>ax.fill_between()</code>.
- If the dictionary key corresponds to the name of a FEDFrame being plotted,
or the name of a group of FEDFrames being plotted, then the value
should be another dictionary mapping keyword arguments for <code>ax.fill_between()</code>
to their values.
- Otherwise, the keys are assumed to be keywords arguments for <code>ax.fill_between()</code>,
and values are the argument values.
In this case, the kwargs are applied
to all lines being plotted.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict-like</code></dt>
<dd>Passed to updated <code>line_kwargs</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>variable</code></dt>
<dd>Dependent on parameter <code>output</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def line(feds, y=&#39;pellets&#39;, bins=None, agg=&#39;mean&#39;, var=&#39;std&#39;,
         omit_na=False, mixed_align=&#39;raise&#39;, output=&#39;plot&#39;,
         xaxis=&#39;auto&#39;, shadedark=True, ax=None, legend=True,
         line_kwargs=None, error_kwargs=None, **kwargs):
    &#39;&#39;&#39;
    Create a line plot, with time on the x-axis and a variable
    of interest on the y-axis.

    Parameters
    ----------
    feds : FEDFrame, list-like, or dict
        FED3 data to be plotted.
        - **FEDFrame**: A single line is plotted for this object
        - **list-like**: If a collection of FEDFrames is passed,
        an individual line is plotted for every FEDFrame within `feds`
        - **dict**: If a `dict` is passed, the data are treated as being
        grouped, and average lines are plotted.  The dict should have
        group labels as keys, and FEDFrame objects as values.  Note that
        the values can be either single FEDFrame objects or list-like collections
        of them.  Though if all the values of the `dict` are single FEDFrame
        objects, the data will be treated as if there are no groups.
    y : str, optional
        Metric to plot on y-axis. See `fed3.metrics` or `fed3.metrics.list_metrics()`
        for available options.  The default is &#39;pellets&#39;.
    bins : pandas time offset string, optional
        Frequency string denoting how data should be binned when plotting.
        The default is None, in which case there is no binnings.  Examples
        are &#39;1H&#39; for 1 hour or &#39;15T&#39; for 15 minutes.  When group data are passed
        (see `feds`) and `bins` is not specified, defaults to `1H`.
    agg : str or callable, optional
        Function to aggregate data from multiple FEDFrames in a group (for each
        temporal bin).  The default is &#39;mean&#39;.  Only relevant when grouped
        data are being plotted.
    var : str or callable, optional
        Function to measure variation of data from multiple FEDFrames in a group
        (for each temporal bin).  The default is &#39;std&#39;.  The output of this
        callable is represented as a shaded error bar around the line.
        Only relevant when grouped data are being plotted. The default is &#39;std&#39;.
    omit_na : bool, optional
        When True, omits bins in a group where at least one FEDFrame has
        missing data. Only relevant when grouped data are being plotted.
        The default is False.
    mixed_align : str, optional
        Protocol when encountering FEDFrames with mixed aligment being plotted.
        The default is &#39;raise&#39;.  See `fed3.core.fedfuncs.screen_mixed_alignment()`
        for options.
    output : str, optional
        Specify function behavior and return value. The default is &#39;plot&#39;.
        - **plot**: Plot is created and the matplotlib Figure is returned.
        - **data**: Plot is created, and underlying processed data are returned
        (as a pandas DataFrame).
        - **both**: Plot is created, and the return value is a 2-tuple with
        the first element being the Figure, and second element being the data.
        - **dataonly**: Plot is NOT created; only the processed data are returned.
        - anything else: a `ValueError` is raised.
    xaxis : str, optional
        X-axis type to used for plotting. This is usually determined by the
        alignment of the FEDFrames, and should be handled by &#39;auto&#39; (default).
        Other options are &#39;datetime&#39;, &#39;time&#39;, and &#39;elapsed&#39;.
    shadedark : bool, optional
        When applicable based on the FEDFrame alignment, create shaded
        boxes indicating when the lights were off. The default is True.
    ax : matplotlib Axes, optional
        Axes to direct the plotting to. The default is None, in which case
        `plt.gca()` is used.
    legend : bool, optional
        Create a legend. The default is True.
    line_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.plot()`.
        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.plot()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.plot()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.
    error_kwargs : dict-like, optional
        Dictionary for providing kwargs to matplotlib, specifically `ax.fill_between()`.
        - If the dictionary key corresponds to the name of a FEDFrame being plotted,
        or the name of a group of FEDFrames being plotted, then the value
        should be another dictionary mapping keyword arguments for `ax.fill_between()`
        to their values.
        - Otherwise, the keys are assumed to be keywords arguments for `ax.fill_between()`,
        and values are the argument values.  In this case, the kwargs are applied
        to all lines being plotted.
    **kwargs : dict-like
        Passed to updated `line_kwargs`.

    Returns
    -------
    variable
        Dependent on parameter `output`.

    &#39;&#39;&#39;

    feds_dict = _parse_feds(feds)
    is_group = any(len(v) &gt; 1 for v in feds_dict.values())
    bins = &#39;1H&#39; if is_group and bins is None else bins
    var = var if is_group else None

    return _simple_plot(kind=&#39;line&#39;,
                        feds_dict=feds_dict,
                        y=y,
                        bins=bins,
                        agg=agg,
                        var=var,
                        omit_na=omit_na,
                        mixed_align=mixed_align,
                        output=output,
                        xaxis=xaxis,
                        shadedark=shadedark,
                        ax=ax,
                        legend=legend,
                        plot_kwargs=line_kwargs,
                        error_kwargs=error_kwargs,
                        **kwargs)</code></pre>
</details>
</dd>
<dt id="fed3.plot.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>feds, y='pellets', bins=None, agg='mean', var='std', omit_na=False, mixed_align='raise', output='plot', xaxis='auto', shadedark=True, ax=None, legend=True, point_kwargs=None, error_kwargs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(feds, y=&#39;pellets&#39;, bins=None, agg=&#39;mean&#39;, var=&#39;std&#39;,
            omit_na=False, mixed_align=&#39;raise&#39;, output=&#39;plot&#39;,
            xaxis=&#39;auto&#39;, shadedark=True, ax=None, legend=True,
            point_kwargs=None, error_kwargs=None, **kwargs):

    feds_dict = _parse_feds(feds)
    is_group = any(len(v) &gt; 1 for v in feds_dict.values())
    bins = &#39;1H&#39; if is_group and bins is None else bins
    var = var if is_group else None

    return _simple_plot(kind=&#39;scatter&#39;,
                        feds_dict=feds_dict,
                        y=y,
                        bins=bins,
                        agg=agg,
                        var=var,
                        omit_na=omit_na,
                        mixed_align=mixed_align,
                        output=output,
                        xaxis=xaxis,
                        shadedark=shadedark,
                        ax=ax,
                        legend=legend,
                        plot_kwargs=point_kwargs,
                        error_kwargs=error_kwargs,
                        **kwargs)</code></pre>
</details>
</dd>
<dt id="fed3.plot.set_colorcycle"><code class="name flex">
<span>def <span class="ident">set_colorcycle</span></span>(<span>colors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_colorcycle(colors):
    COLORCYCLE[:] = list(colors)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#plotting-with-fed3">Plotting with fed3</a><ul>
<li><a href="#import-fed3plot">Import fed3.plot</a></li>
<li><a href="#example-data">Example data</a></li>
<li><a href="#basic-plotting">Basic plotting</a><ul>
<li><a href="#the-hello-world-plot">The "Hello World" plot</a></li>
<li><a href="#plotting-multiple-feds">Plotting multiple FEDs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fed3" href="../index.html">fed3</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fed3.plot.barchart" href="barchart.html">fed3.plot.barchart</a></code></li>
<li><code><a title="fed3.plot.chronogram" href="chronogram.html">fed3.plot.chronogram</a></code></li>
<li><code><a title="fed3.plot.format_axis" href="format_axis.html">fed3.plot.format_axis</a></code></li>
<li><code><a title="fed3.plot.helpers" href="helpers.html">fed3.plot.helpers</a></code></li>
<li><code><a title="fed3.plot.shadedark" href="shadedark.html">fed3.plot.shadedark</a></code></li>
<li><code><a title="fed3.plot.simple" href="simple.html">fed3.plot.simple</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="fed3.plot.bar" href="#fed3.plot.bar">bar</a></code></li>
<li><code><a title="fed3.plot.chronogram_circle" href="#fed3.plot.chronogram_circle">chronogram_circle</a></code></li>
<li><code><a title="fed3.plot.chronogram_line" href="#fed3.plot.chronogram_line">chronogram_line</a></code></li>
<li><code><a title="fed3.plot.chronogram_spiny" href="#fed3.plot.chronogram_spiny">chronogram_spiny</a></code></li>
<li><code><a title="fed3.plot.ipi" href="#fed3.plot.ipi">ipi</a></code></li>
<li><code><a title="fed3.plot.line" href="#fed3.plot.line">line</a></code></li>
<li><code><a title="fed3.plot.scatter" href="#fed3.plot.scatter">scatter</a></code></li>
<li><code><a title="fed3.plot.set_colorcycle" href="#fed3.plot.set_colorcycle">set_colorcycle</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>